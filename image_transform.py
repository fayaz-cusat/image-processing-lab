# -*- coding: utf-8 -*-
"""Image Transform.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10I8UQEbOJLfIWAq9jVRjzbsBBthsE54y
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA

# Load the grayscale image
image_path = '/content/cameraman-testimage.png'  # Replace with your image path or URL
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Check if the image is loaded correctly
if image is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    print(f"Image loaded successfully with shape: {image.shape}")

# 1. Discrete Fourier Transform (DFT)
def dft_transform(image):
    # Perform DFT
    dft = cv2.dft(np.float32(image), flags=cv2.DFT_COMPLEX_OUTPUT)
    dft_shift = np.fft.fftshift(dft)  # Shift zero frequency component to the center

    # Magnitude spectrum
    magnitude_spectrum = cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1])

    return magnitude_spectrum

# 2. Z-Transform (Simplified version using FFT)
def z_transform(image):
    # We can use FFT for an approximate Z-transform
    z_transform_result = np.fft.fft2(image)  # Perform 2D FFT as a proxy for Z-transform

    # Shift zero frequency component to center and compute magnitude
    z_shifted = np.fft.fftshift(z_transform_result)
    magnitude_spectrum = np.abs(z_shifted)

    return magnitude_spectrum

# 3. KL Transform (Using PCA for dimensionality reduction)
def kl_transform(image):
    # Flatten the image into a 2D array where each row is a pixel (height x width x 1)
    image_reshaped = image.flatten().reshape(-1, 1)

    # Perform PCA (KL Transform)
    pca = PCA(n_components=1)
    pca_result = pca.fit_transform(image_reshaped)

    # Reshape the PCA result back to the image size
    kl_transformed = pca_result.reshape(image.shape)

    return kl_transformed

# Perform each transform
dft_result = dft_transform(image)
z_result = z_transform(image)

# Perform KL Transform only if the image is valid
if image is not None:
    kl_result = kl_transform(image)

# Plot the results
plt.figure(figsize=(12, 12))

# Original image
plt.subplot(2, 2, 1)
plt.imshow(image, cmap='gray')
plt.title("Original Image")
plt.axis('off')

# DFT magnitude spectrum
plt.subplot(2, 2, 2)
plt.imshow(np.log(dft_result + 1), cmap='gray')
plt.title("DFT Magnitude Spectrum")
plt.axis('off')

# Z-Transform magnitude spectrum
plt.subplot(2, 2, 3)
plt.imshow(np.log(z_result + 1), cmap='gray')
plt.title("Z-Transform Magnitude Spectrum")
plt.axis('off')

# KL Transform result (PCA Projection)
plt.subplot(2, 2, 4)
if image is not None:
    plt.imshow(kl_result, cmap='gray')
    plt.title("KL Transform (PCA Projection)")
    plt.axis('off')
else:
    plt.text(0.5, 0.5, "Image not loaded correctly", ha='center', va='center', fontsize=12)
    plt.axis('off')

plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.decomposition import PCA
# Load the grayscale image
image_path = '/content/cameraman-testimage.png'  # Replace with your image path or URL
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

# Check if the image is loaded correctly
if image is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    print(f"Image loaded successfully with shape: {image.shape}")

# 1. Discrete Fourier Transform (DFT)
def dft_transform(image):
    # Perform DFT
    dft = cv2.dft(np.float32(image), flags=cv2.DFT_COMPLEX_OUTPUT)
    dft_shift = np.fft.fftshift(dft)  # Shift zero frequency component to the center

    # Magnitude spectrum
    magnitude_spectrum = cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1])

    return magnitude_spectrum

# 2. Z-Transform (Simplified version using FFT)
def z_transform(image):
    # We can use FFT for an approximate Z-transform
    z_transform_result = np.fft.fft2(image)  # Perform 2D FFT as a proxy for Z-transform

    # Shift zero frequency component to center and compute magnitude
    z_shifted = np.fft.fftshift(z_transform_result)
    magnitude_spectrum = np.abs(z_shifted)

    return magnitude_spectrum

def kl_transform(image, n_components=1): # Change n_components to 1
    # Reshape the image to a 2D matrix (each row is a pixel, each column a feature)
    image_reshaped = image.reshape(-1, 1)  # Flatten the image to a single column vector

    # Apply PCA for dimensionality reduction
    pca = PCA(n_components=n_components)
    pca_result = pca.fit_transform(image_reshaped)

    # Reconstruct the image from the PCA components
    image_reconstructed = pca.inverse_transform(pca_result)

    # Reshape back to the original image shape
    kl_transformed = image_reconstructed.reshape(image.shape)

    return kl_transformed


# Perform each transform
dft_result = dft_transform(image)
z_result = z_transform(image)

# Perform KL Transform only if the image is valid
if image is not None:
    kl_result = kl_transform(image)

# Plot the results
plt.figure(figsize=(12, 12))

# Original image
plt.subplot(2, 2, 1)
plt.imshow(image, cmap='gray')
plt.title("Original Image")
plt.axis('off')

# DFT magnitude spectrum
plt.subplot(2, 2, 2)
plt.imshow(np.log(dft_result + 1), cmap='gray')
plt.title("DFT Magnitude Spectrum")
plt.axis('off')

# Z-Transform magnitude spectrum
plt.subplot(2, 2, 3)
plt.imshow(np.log(z_result + 1), cmap='gray')
plt.title("Z-Transform Magnitude Spectrum")
plt.axis('off')

# KL Transform result (PCA Projection)
plt.subplot(2, 2, 4)
if image is not None:
    plt.imshow(kl_result, cmap='gray')
    plt.title("KL Transform (PCA Projection)")
    plt.axis('off')
else:
    plt.text(0.5, 0.5, "Image not loaded correctly", ha='center', va='center', fontsize=12)
    plt.axis('off')

plt.show()